<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Ish's Blog</title><link>https://ishabbi.tech/posts/</link><description>Recent content in Posts on Ish's Blog</description><generator>Hugo</generator><language>en</language><lastBuildDate>Sun, 20 Apr 2025 12:45:00 +0530</lastBuildDate><atom:link href="https://ishabbi.tech/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Scoring your accessibility observations</title><link>https://ishabbi.tech/posts/a11y-score-cards/</link><pubDate>Sun, 20 Apr 2025 12:45:00 +0530</pubDate><guid>https://ishabbi.tech/posts/a11y-score-cards/</guid><description>&lt;p>In todayâ€™s digital-first world, accessibility plays a pivotal role in promoting diversity and inclusivity across communication platforms and digital tools. For the internet, this movement began with the W3Câ€™s first &lt;a href="https://www.w3.org/WAI/standards-guidelines/wcag/" class="external-link" target="_blank" rel="noopener">Web Content Accessibility Guidelines&lt;/a> (WCAG), aimed at making the web more accessible for everyone.&lt;/p>
&lt;p>While WCAG 1.0, released in 1999, laid the foundation for web accessibility. Its successor, WCAG 2.0, introduced a more robust and technology-agnostic framework based on four core principles â€” Perceivable, Operable, Understandable, and Robust (POUR) â€” to better support the needs of users with disabilities and improve digital accessibility standards.&lt;/p></description></item><item><title> QA Metrics: Leading and Lagging Indicators Every Tester Should Know</title><link>https://ishabbi.tech/posts/qa-best-practices-underdogs/</link><pubDate>Mon, 26 Aug 2024 19:53:00 +0530</pubDate><guid>https://ishabbi.tech/posts/qa-best-practices-underdogs/</guid><description>&lt;p>Hey there, fellow techies and aspiring QA professionals! ðŸ‘‹ Today, we&amp;rsquo;re embarking on an in-depth journey through the world of Quality Assurance metrics. We&amp;rsquo;ll be unpacking the dynamic duo of leading and lagging indicators, exploring their significance, and diving into some fascinating testing phenomena. So grab your favorite debugging tool (and maybe a coffee), because this deep dive into the QA landscape is going to be both comprehensive and enlightening!&lt;/p></description></item><item><title>Fetch GraphQL query from an Apollo client using APQ - Part 2</title><link>https://ishabbi.tech/posts/debug-apq-extension-part2/</link><pubDate>Sat, 10 Aug 2024 00:55:00 +0530</pubDate><guid>https://ishabbi.tech/posts/debug-apq-extension-part2/</guid><description>&lt;style>
 .img-shadow {
 box-shadow: 0 2px 2px 2px rgba(0, 0, 0, 0.2);
 }
&lt;/style>
&lt;div style="text-align: justify">
&lt;p>As discussed in &lt;a href="https://ishabbi.tech/posts/debug-apq-extension-part1" >part-1&lt;/a> of this blog, when using apollo client one can boost the performance of the graphql queries by using &lt;strong>&amp;ldquo;Automatic persisted queries&amp;rdquo; or APQ&lt;/strong>. By using APQ, the server caches each requests initiated from the browser against a hash which if not found, forces the web browser to re-send the request with the complete graphql query.&lt;/p></description></item><item><title>Fetch GraphQL query from an Apollo client using APQ - Part 1</title><link>https://ishabbi.tech/posts/debug-apq-extension-part1/</link><pubDate>Sat, 20 Jul 2024 23:55:00 +0530</pubDate><guid>https://ishabbi.tech/posts/debug-apq-extension-part1/</guid><description>&lt;p>&lt;strong>APIs (Application Programming Interfaces)&lt;/strong> for web applications have evolved significantly since the early days of the internet. Initially, APIs were simple and used primarily for data exchange between server and client, often through protocols like SOAP (Simple Object Access Protocol). These early APIs were cumbersome and required extensive documentation and strict adherence to protocols.&lt;/p>
&lt;p>The rise of &lt;strong>REST (Representational State Transfer)&lt;/strong> in the early 2000s marked a major shift, offering a more flexible and scalable approach to building web APIs. RESTful APIs leverage standard HTTP methods, making them easier to use and more intuitive. However, 2015 saw a paradigm shift, Facebook (now Meta Inc.) introduced &lt;strong>GraphQL&lt;/strong> to the world, allowing clients to request specific data, resulting to it&amp;rsquo;s rapid adoption amongst enterprises. According to reports, it is projected that by 2025, &lt;em>over 50% of enterprises will use GraphQL in production, up from less than 10% in 2021&lt;/em>.&lt;/p></description></item><item><title>Understanding the Selenium Webdriver</title><link>https://ishabbi.tech/posts/understanding-selenium-webdriver/</link><pubDate>Wed, 19 Feb 2020 21:47:38 +0530</pubDate><guid>https://ishabbi.tech/posts/understanding-selenium-webdriver/</guid><description>&lt;div style="text-align: justify">
Over the course of time, my pursuit for understanding the internals of Selenium compelled me to crawl the corners of the internet
in search for answers. I was searching for something that can help me connect the dots between the the browser and selenium.
&lt;p>With countless blogs and documentation fuelling my experiments, here is what I&amp;rsquo;ve been able to learn of the WebDriver and the &lt;a href="https://w3c.github.io/webdriver/" class="external-link" target="_blank" rel="noopener">W3C WebDriver Protocol&lt;/a>.&lt;/p>
&lt;h2 id="what-is-a-webdriver">
 What is a WebDriver?
 &lt;a class="heading-link" href="#what-is-a-webdriver">
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="Link to heading">&lt;/i>
 &lt;span class="sr-only">Link to heading&lt;/span>
 &lt;/a>
&lt;/h2>
&lt;div style="text-align: justify">
According to the selenium documentation :
&lt;blockquote>
WebDriver drives a browser natively, as a user would, either locally or on a remote machine using the Selenium server, marks a leap forward in terms of browser automation.
&lt;br/>
&lt;br/>
Selenium WebDriver refers to both the language bindings and the implementations of the individual browser controlling code. This is commonly referred to as just WebDriver.
&lt;br/>
&lt;br/>
Selenium WebDriver is a W3C Recommendation
&lt;/blockquote>
&lt;p>To further simplify the understanding, I define the WebDriver as :&lt;/p></description></item><item><title>Generating HTML reports for your tests viaÂ Gradle</title><link>https://ishabbi.tech/posts/gradle-reporting-easy-way/</link><pubDate>Mon, 17 Feb 2020 18:45:18 +0530</pubDate><guid>https://ishabbi.tech/posts/gradle-reporting-easy-way/</guid><description>&lt;div style="text-align: justify">
In the test automation world, visualizing the results of your tests have an equal priority in conjunction with the tests being executed. How will you be able to make the most out of the tests being executed? Would a simple report having Pass/Fail ratio along with the screenshots suffice? or the reports need to be more comprehensive? maybe the report needs to keep a trend of the tests being executed over time? or needs to have a documented step for each action?
&lt;p>There are many frameworks for your reporting needs (two of the most notable ones are &lt;a href="http://allure.qatools.ru/" class="external-link" target="_blank" rel="noopener">Allure&lt;/a> and &lt;a href="https://extentreports.com/" class="external-link" target="_blank" rel="noopener">Extent&lt;/a> reports) in the market today, even gradle provides an in-house html report on execution of a junit/testng test.&lt;/p></description></item></channel></rss>